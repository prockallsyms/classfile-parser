use crate::{
    attribute_info::{AttributeInfo, AttributeInfoVariant, CodeAttribute},
    InterpretInner,
};

use binrw::{binrw, BinResult};

#[derive(Clone, Debug)]
#[binrw]
#[brw(big)]
pub struct MethodInfo {
    pub access_flags: MethodAccessFlags,
    pub name_index: u16,
    pub descriptor_index: u16,
    pub attributes_count: u16,
    #[br(count = attributes_count)]
    pub attributes: Vec<AttributeInfo>,
}

impl InterpretInner for MethodInfo {
    fn interpret_inner(&mut self, const_pool: &Vec<crate::constant_info::ConstantInfo>) {
        for attr in &mut self.attributes {
            attr.interpret_inner(const_pool);
        }
    }
}

impl MethodInfo {
    /// Returns a reference to the Code attribute, if present.
    pub fn code(&self) -> Option<&CodeAttribute> {
        self.attributes.iter().find_map(|a| match &a.info_parsed {
            Some(AttributeInfoVariant::Code(c)) => Some(c),
            _ => None,
        })
    }

    /// Returns a mutable reference to the Code attribute, if present.
    pub fn code_mut(&mut self) -> Option<&mut CodeAttribute> {
        self.attributes
            .iter_mut()
            .find_map(|a| match &mut a.info_parsed {
                Some(AttributeInfoVariant::Code(c)) => Some(c),
                _ => None,
            })
    }

    /// Returns a reference to the AttributeInfo containing the Code attribute.
    /// Useful when you need to call `sync_from_parsed()` after modifying the code.
    pub fn code_attribute_info(&self) -> Option<&AttributeInfo> {
        self.attributes
            .iter()
            .find(|a| matches!(&a.info_parsed, Some(AttributeInfoVariant::Code(_))))
    }

    /// Returns a mutable reference to the AttributeInfo containing the Code attribute.
    /// Useful when you need to call `sync_from_parsed()` after modifying the code.
    pub fn code_attribute_info_mut(&mut self) -> Option<&mut AttributeInfo> {
        self.attributes
            .iter_mut()
            .find(|a| matches!(&a.info_parsed, Some(AttributeInfoVariant::Code(_))))
    }

    /// Access the CodeAttribute inside a closure and auto-sync when done.
    ///
    /// Returns `None` if no Code attribute exists (e.g. abstract method),
    /// `Some(Err(_))` if sync fails, `Some(Ok(R))` on success.
    pub fn with_code<F, R>(&mut self, f: F) -> Option<BinResult<R>>
    where
        F: FnOnce(&mut CodeAttribute) -> R,
    {
        let attr = self
            .attributes
            .iter_mut()
            .find(|a| matches!(&a.info_parsed, Some(AttributeInfoVariant::Code(_))))?;
        let result = match &mut attr.info_parsed {
            Some(AttributeInfoVariant::Code(code)) => f(code),
            _ => unreachable!(),
        };
        Some(attr.sync_from_parsed().map(|()| result))
    }
}

#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[binrw]
pub struct MethodAccessFlags(u16);

bitflags! {
    impl MethodAccessFlags: u16 {
        const PUBLIC = 0x0001;       // 	Declared public; may be accessed from outside its package.
        const PRIVATE = 0x0002;      // 	Declared private; accessible only within the defining class.
        const PROTECTED = 0x0004;    // 	Declared protected; may be accessed within subclasses.
        const STATIC = 0x0008;       // 	Declared static.
        const FINAL = 0x0010;        // 	Declared final; must not be overridden.
        const SYNCHRONIZED = 0x0020; // 	Declared synchronized; invocation is wrapped by a monitor use.
        const BRIDGE = 0x0040;       // 	A bridge method, generated by the compiler.
        const VARARGS = 0x0080;      // 	Declared with variable number of arguments.
        const NATIVE = 0x0100;       //  Declared native; implemented in a language other than Java
        const ABSTRACT = 0x0400;     // 	Declared abstract; no implementation is provided.
        const STRICT = 0x0800;       // 	Declared strictfp; floating-point mode is FP-strict.
        const SYNTHETIC = 0x1000;    // 	Declared synthetic; not present in the source code.
    }
}
